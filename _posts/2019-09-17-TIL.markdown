---
layout: post
title:  "TIL what is tuple splat"
date:   2019-09-17 19:17:00 +0200
categories: TIL, Swift, tuple splat
---
Having this:

```Swift
let colors: [[PaletteColorPicker.AccessibleColor]] = saturatedColors.map { row in
    row.map { acHex($0) }
}
```

I always look into a way to simplify map to something like:

```Swift
let colors: [[PaletteColorPicker.AccessibleColor]] = saturatedColors.map { row in
    row.map( PaletteColorPicker.AccessibleColor.init(hex:) )
}
```

But `PaletteColorPicker.AccessibleColor` is an alias to tuple:

```Swift
typealias AccessibleColor = (color: UIColor, label: String)
```

And we can't extend tuple with convenience initializer. If you try to do something like following you get an error:

```Swift 
private extension PaletteColorPicker.AccessibleColor { // error Non-nominal type 'PaletteColorPicker.AccessibleColor' (aka '(color: UIColor, label: String)') cannot be extended
    init(hex: String) {
        // ...
    }
}
```

Looks like a gap in Swift type system.

As it often happens, when touching some topic I jumped to post on subject [Tuples in Swift](https://andybargh.com/tuples-in-swift/).

Didn't know that this produces a warning about empty tuple:

```Swift
let emptyTuple = ()
```

Statement that Swift makes single value tuple just a value of type inside of tuple.

```Swift
let myValue1 = (1.0)   // actually is (Double) like in
let myValue2: (Double) 
```

This trick of swapping two variable values is so nice!

```Swift
var a = 1, b = 2
(a, b) = (b, a)
```

Hm, feature of passing parameters to function as tuple (which is called "tuple splat") was removed from Swift two years ago (in September of 2017) with [Remove implicit tuple splat behavior from function applications](https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md).
